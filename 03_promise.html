<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>3. Promise</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
      }
      .container {
        max-width: 600px;
        margin: auto;
        padding: 20px;
        border: 1px solid lightgray;
        border-radius: 8px;
      }
      button {
        padding: 10px 15px;
        font-size: 16px;
        cursor: pointer;
        margin: 5px;
      }
      #log {
        margin-top: 20px;
        padding: 10px;
        border: 1px solid black;
        background-color: ghostwhite;
        min-height: 150px;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>3. Promise로 콜백 지옥 탈출하기</h1>
      <p>
        Promise의 .then() 체이닝을 통해 코드가 어떻게 개선되는지 확인하세요.
      </p>
      <button id="success-btn">성공 시나리오</button>
      <button id="fail-btn">실패 시나리오</button>
      <div id="log"></div>
    </div>

    <script>
      const successBtn = document.getElementById("success-btn");
      const failBtn = document.getElementById("fail-btn");
      const logDiv = document.getElementById("log");

      const log = (message, isError = false) => {
        logDiv.innerHTML += `<div style="color: ${
          isError ? "red" : "black"
        };">${message}</div>`;
      };

      /*
        ==================================================================================
        🎯 Promise란?
        ==================================================================================
        - 비동기 작업의 최종 성공 또는 실패를 나타내는 객체입니다.
        - 성공은 resolve, 실패는 reject 함수를 호출하여 결과를 전달합니다.
        - .then(onFulfilled, onRejected): 작업 성공/실패 시 실행될 함수를 등록합니다.
        - .catch(onRejected): 작업 실패 시 실행될 함수를 등록합니다. .then(null, onRejected)과 같습니다.
        - .finally(onFinally): 성공/실패 여부와 상관없이 마지막에 항상 실행됩니다.
        */

      // Promise를 반환하는 비동기 작업 함수
      function asyncTask(taskName, duration, shouldSucceed) {
        log(`⏳ '${taskName}' 작업 시작...`);
        // Promise 객체를 생성하여 즉시 반환합니다.
        return new Promise((resolve, reject) => {
          setTimeout(() => {
            if (shouldSucceed) {
              log(`✅ '${taskName}' 작업 성공!`);
              resolve(`${taskName}의 결과물`); // 성공 시 resolve 호출
            } else {
              log(`❌ '${taskName}' 작업 실패!`);
              reject(new Error(`'${taskName}'에서 에러 발생`)); // 실패 시 reject 호출
            }
          }, duration);
        });
      }

      // 성공 시나리오 버튼 클릭 이벤트
      successBtn.addEventListener("click", () => {
        logDiv.innerHTML = "";

        // 🧑‍💻 여기에 코드를 작성하세요.
        // 1. asyncTask('사용자 정보 가져오기', 1000, true)를 호출합니다.
        // 2. .then()을 사용하여 첫 번째 작업이 성공하면 asyncTask('게시물 목록 가져오기', 1000, true)를 호출합니다.
        // 3. .then()을 사용하여 두 번째 작업이 성공하면 asyncTask('댓글 정보 가져오기', 1000, true)를 호출합니다.
        // 4. 마지막 .then()에서 모든 작업이 완료되었음을 알리는 로그를 출력합니다.
        // 5. .catch()를 사용하여 혹시 모를 에러를 처리합니다.
      });

      // 실패 시나리오 버튼 클릭 이벤트
      failBtn.addEventListener("click", () => {
        logDiv.innerHTML = "";

        // 🧑‍💻 여기에 코드를 작성하세요.
        // 1. asyncTask를 순서대로 호출하되, 두 번째 작업인 '게시물 목록 가져오기'가 실패하도록
        //    shouldSucceed 인자를 false로 설정하여 호출합니다.
        // 2. 세 번째 작업은 실행되지 않아야 합니다.
        // 3. .catch()를 사용하여 "최종 에러 처리: [에러메시지]" 형식으로 로그를 출력합니다.
      });
    </script>
  </body>
</html>
